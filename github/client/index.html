<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto SuperTrend Monitor</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        [v-cloak] { display: none; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: radial-gradient(1200px 500px at 10% 10%, #0b0f1e 0%, #0b0f1e 30%, #121329 60%, #131135 100%); color: #e6edf3; min-height: 100vh; }
        .container { max-width: 1400px; margin: 0 auto; padding: 20px; }
        .header {
            text-align: center;
            padding: 40px 20px;
            margin-bottom: 30px;
        }
        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, #6366f1, #a855f7, #0ea5e9);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
        }
        .header p {
            color: #64748b;
            font-size: 1rem;
        }
        .api-badge { background: #238636; color: white; padding: 4px 8px; border-radius: 4px; font-size: 0.7rem; font-weight: 600; }
        .status-bar { display: flex; justify-content: space-between; align-items: center; padding: 14px 18px; background: rgba(22,27,34,0.6); border: 1px solid #2b3141; border-radius: 14px; margin-bottom: 16px; backdrop-filter: blur(4px); flex-wrap: wrap; gap: 10px; }
        .status-left { display: flex; align-items: center; gap: 20px; flex-wrap: wrap; color: #7d8590; font-size: 0.85rem; }
        .status-item { display: flex; align-items: center; gap: 6px; }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; background: #3fb950; animation: pulse 2s infinite; }
        .status-dot.loading { background: #d29922; }
        .status-dot.error { background: #f85149; animation: none; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .controls { display: flex; gap: 10px; margin-bottom: 16px; flex-wrap: wrap; justify-content: center; }
        .btn { padding: 10px 18px; border: 1px solid #30363d; border-radius: 999px; background: #1b2230; color: #e6edf3; cursor: pointer; font-size: 0.9rem; transition: all 0.2s; }
        .btn:hover { background: #283046; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn.active { background: #5b5299; border-color: #8b7cf7; color: #fff; }
        .progress-bar { width: 100%; height: 4px; background: #30363d; border-radius: 2px; overflow: hidden; margin-top: 8px; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #238636, #3fb950); transition: width 0.3s ease; width: 0%; }
        .stats-row { display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px; margin-bottom: 20px; }
        .stat-card { background: rgba(22,27,34,0.6); border: 1px solid #2b3141; border-radius: 16px; padding: 18px; text-align: center; }
        .stat-card .label { color: #7d8590; font-size: 0.75rem; margin-bottom: 6px; text-transform: uppercase; }
        .stat-card .value { font-size: 1.6rem; font-weight: 700; }
        .stat-card .value.green { color: #3fb950; } .stat-card .value.red { color: #f85149; } .stat-card .value.yellow { color: #d29922; } .stat-card .value.blue { color: #58a6ff; }
        .table-container { background: rgba(22,27,34,0.6); border: 1px solid #2b3141; border-radius: 16px; overflow-x: auto; }
        table { width: 100%; border-collapse: collapse; min-width: 800px; }
        th { background: transparent; padding: 12px 16px; text-align: left; font-weight: 500; color: #7d8590; font-size: 0.75rem; text-transform: uppercase; border-bottom: 1px solid #30363d; white-space: nowrap; }
        td { padding: 12px 16px; border-bottom: 1px solid #21262d; vertical-align: middle; }
        tr:hover { background: #1c2128; }
        .coin-info { display: flex; align-items: center; gap: 10px; }
        .coin-icon { width: 36px; height: 36px; border-radius: 50%; display: flex; align-items: center; justify-content: center; background: #1b2230; overflow: hidden; }
        .coin-icon img { width: 70%; height: 70%; object-fit: contain; display: block; }
        .coin-icon-fallback { width: 100%; height: 100%; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.7rem; font-weight: 700; color: #ffffff; }
        .coin-name { font-weight: 500; color: #e6edf3; font-size: 0.9rem; }
        .coin-symbol { color: #7d8590; font-size: 0.8rem; }
        .price { font-weight: 500; color: #e6edf3; font-size: 0.9rem; }
        .trend-badge { display: flex; flex-direction: column; align-items: center; min-width: 52px; border-radius: 6px; overflow: hidden; }
        .trend-badge .tf { font-size: 0.65rem; padding: 2px 6px; background: rgba(255,255,255,0.1); color: #7d8590; width: 100%; text-align: center; }
        .trend-badge .signal { font-size: 0.7rem; font-weight: 600; padding: 4px 8px; width: 100%; text-align: center; }
        .trend-badge.buy { background: rgba(63, 185, 80, 0.15); border: 1px solid rgba(63, 185, 80, 0.3); }
        .trend-badge.buy .signal { color: #3fb950; }
        .trend-badge.sell { background: rgba(248, 81, 73, 0.15); border: 1px solid rgba(248, 81, 73, 0.3); }
        .trend-badge.sell .signal { color: #f85149; }
        .trend-badge.neutral { background: rgba(210, 153, 34, 0.15); border: 1px solid rgba(210, 153, 34, 0.3); }
        .trend-badge.neutral .signal { color: #d29922; }
        .trend-badge.loading { background: rgba(88, 166, 255, 0.1); border: 1px solid rgba(88, 166, 255, 0.2); }
        .trend-badge.loading .signal { color: #58a6ff; }
        .mini-chart { width: 80px; height: 32px; display: block; }
        .score-badge { display: inline-block; padding: 6px 10px; border-radius: 999px; font-size: 0.8rem; font-weight: 600; border: 1px solid #30363d; }
        .score-strong-buy { color: #3fb950; background: rgba(63,185,80,0.15); border-color: rgba(63,185,80,0.3); }
        .score-buy { color: #2ea043; background: rgba(46,160,67,0.12); border-color: rgba(46,160,67,0.25); }
        .score-neutral { color: #d29922; background: rgba(210,153,34,0.12); border-color: rgba(210,153,34,0.25); }
        .score-sell { color: #f85149; background: rgba(248,81,73,0.12); border-color: rgba(248,81,73,0.25); }
        .score-strong-sell { color: #da3633; background: rgba(218,54,51,0.12); border-color: rgba(218,54,51,0.25); }
        @media (max-width: 900px) { .stats-row { grid-template-columns: repeat(2, 1fr); } }
    </style>
</head>
<body>
    <div id="app" v-cloak class="container">
        <header class="header">
            <h1>ğŸš€ Crypto SuperTrend Dashboard</h1>
            <p>å®æ—¶ç›‘æ§å¸‚å€¼å‰100åŠ å¯†è´§å¸çš„å¤šå‘¨æœŸè¶…çº§è¶‹åŠ¿æŒ‡æ ‡ <span class="api-badge">OKX API</span></p>
        </header>

        <div class="status-bar">
            <div class="status-left">
                <div class="status-item">
                    <span :class="['status-dot', loading ? 'loading' : '']"></span>
                    <span>{{ loading ? 'æ­£åœ¨è¿æ¥...' : 'å·²è¿æ¥' }}</span>
                </div>
                <div class="status-item">
                    <span>æœ€åæ›´æ–°ï¼š</span>
                    <span>{{ lastUpdatedFormatted }}</span>
                </div>
            </div>
            <div>
                <button class="btn" @click="fetchData" :disabled="loading">{{ loading ? 'â³ åŠ è½½ä¸­...' : 'ğŸ”„ åˆ·æ–°æ•°æ®' }}</button>
            </div>
        </div>

        <div class="progress-bar">
            <div class="progress-fill" :style="{ width: loadPercent + '%' }"></div>
        </div>

        <div class="controls">
            <input v-model="searchQuery" type="text" placeholder="æœç´¢å¸ç§..." class="btn" style="min-width:260px;">
            <button class="btn" @click="sortBy('rank')">æŒ‰æ’åæ’åº {{ sortKey==='rank' ? (sortOrder==='asc'?'â†‘':'â†“') : '' }}</button>
            <button class="btn" @click="sortBy('price')">æŒ‰ä»·æ ¼æ’åº {{ sortKey==='price' ? (sortOrder==='asc'?'â†‘':'â†“') : '' }}</button>
            <button class="btn" :class="{ active: filterStatus==='all' }" @click="setFilter('all')">å…¨éƒ¨</button>
            <button class="btn" :class="{ active: filterStatus==='bullish' }" @click="setFilter('bullish')">ğŸŸ¢ çœ‹æ¶¨</button>
            <button class="btn" :class="{ active: filterStatus==='bearish' }" @click="setFilter('bearish')">ğŸ”´ çœ‹è·Œ</button>
            <button class="btn" :class="{ active: filterStatus==='neutral' }" @click="setFilter('neutral')">ğŸŸ¡ ä¸­æ€§</button>
        </div>

        <div class="stats-row">
            <div class="stat-card"><div class="label">çœ‹æ¶¨ä¿¡å·</div><div class="value green">{{ stats.bullish }}</div></div>
            <div class="stat-card"><div class="label">çœ‹è·Œä¿¡å·</div><div class="value red">{{ stats.bearish }}</div></div>
            <div class="stat-card"><div class="label">ä¸­æ€§ä¿¡å·</div><div class="value yellow">{{ stats.neutral }}</div></div>
            <div class="stat-card"><div class="label">å·²åŠ è½½</div><div class="value blue">{{ loadedCount }}/{{ coins.length }}</div></div>
        </div>

        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th>#</th>
                        <th>å¸ç§</th>
                        <th>ä»·æ ¼</th>
                        <th>15åˆ†é’Ÿ</th>
                        <th>1å°æ—¶</th>
                        <th>4å°æ—¶</th>
                        <th>æ—¥çº¿</th>
                        <th>ç»¼åˆè¯„åˆ†</th>
                        <th>è¶‹åŠ¿å›¾</th>
                    </tr>
                </thead>
                <tbody>
                    <tr v-for="coin in filteredCoins" :key="coin.symbol">
                        <td>{{ coin.rank }}</td>
                        <td>
                            <div class="coin-info">
                                <div class="coin-icon">
                                    <img v-if="coin.image" :src="coin.image" :alt="coin.symbol" @error="coin.image = null">
                                    <div v-else class="coin-icon-fallback" :style="{ background: coinColor(coin.symbol) }">
                                        {{ coin.symbol.slice(0,3) }}
                                    </div>
                                </div>
                                <div>
                                    <div class="coin-name">{{ coin.name }}</div>
                                    <div class="coin-symbol">{{ coin.symbol }}/USDT</div>
                                </div>
                            </div>
                        </td>
                        <td><div class="price">${{ formatPrice(coin.price) }}</div></td>
                        <td><trend-badge label="15m" :trend="coin.trends?.m15"></trend-badge></td>
                        <td><trend-badge label="1h" :trend="coin.trends?.h1"></trend-badge></td>
                        <td><trend-badge label="4h" :trend="coin.trends?.h4"></trend-badge></td>
                        <td><trend-badge label="1d" :trend="coin.trends?.d1"></trend-badge></td>
                        <td class="score-cell"><span :class="['score-badge', scoreInfo(coin).klass]">{{ scoreInfo(coin).label }}</span></td>
                        <td v-html="generateMiniChart(coin)"></td>
                    </tr>
                    <tr v-if="filteredCoins.length === 0">
                        <td colspan="9" style="text-align:center;padding:40px;">æš‚æ— æ•°æ®æˆ–æ­£åœ¨åŠ è½½â€¦</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <script>
        const { createApp, ref, computed, onMounted } = Vue;

        const TrendBadge = {
            props: ['trend','label'],
            template: `
                <div :class="klass" class="trend-badge">
                    <div class="tf">{{ label }}</div>
                    <div class="signal">{{ text }}</div>
                </div>
            `,
            computed: {
                klass() {
                    if (this.trend === 'UP' ) return 'buy';
                    if (this.trend === 'DOWN') return 'sell';
                    if (this.trend === 'Loading') return 'loading';
                    return 'neutral';
                },
                text() {
                    if (this.trend === 'UP') return 'BUY';
                    if (this.trend === 'DOWN') return 'SELL';
                    if (this.trend === 'Loading') return '...';
                    if (this.trend === 'Error') return 'Error';
                    return 'N/A';
                }
            }
        };

        createApp({
            components: { TrendBadge },
            setup() {
                const coins = ref([]);
                const loading = ref(false);
                const error = ref(null);
                const lastUpdated = ref(null);
                const searchQuery = ref('');
                const sortKey = ref('rank');
                const sortOrder = ref('asc');
                const filterStatus = ref('all');

                const formatPrice = (price) => {
                    if (price == null || isNaN(price)) return '-';
                    if (price < 1) return price.toFixed(6);
                    if (price < 10) return price.toFixed(4);
                    return price.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
                };

                const lastUpdatedFormatted = computed(() => {
                    if (!lastUpdated.value) return 'ä»æœª';
                    return new Date(lastUpdated.value).toLocaleString('zh-CN');
                });

                const filteredCoins = computed(() => {
                    let result = coins.value.slice();

                    if (searchQuery.value) {
                        const q = searchQuery.value.toLowerCase();
                        result = result.filter(c =>
                            c.name.toLowerCase().includes(q) ||
                            c.symbol.toLowerCase().includes(q)
                        );
                    }

                    if (filterStatus.value !== 'all') {
                        result = result.filter(c => {
                            const arr = [c.trends?.m15, c.trends?.h1, c.trends?.h4, c.trends?.d1];
                            const buys = arr.filter(x => x === 'UP').length;
                            const sells = arr.filter(x => x === 'DOWN').length;
                            const category = buys > sells ? 'bullish' : sells > buys ? 'bearish' : 'neutral';
                            return category === filterStatus.value;
                        });
                    }

                    result.sort((a, b) => {
                        let valA = a[sortKey.value];
                        let valB = b[sortKey.value];

                        if (typeof valA === 'string') valA = valA.toLowerCase();
                        if (typeof valB === 'string') valB = valB.toLowerCase();

                        if (valA < valB) return sortOrder.value === 'asc' ? -1 : 1;
                        if (valA > valB) return sortOrder.value === 'asc' ? 1 : -1;
                        return 0;
                    });

                    return result;
                });

                const setFilter = (status) => {
                    filterStatus.value = status;
                };

                const sortBy = (key) => {
                    if (sortKey.value === key) {
                        sortOrder.value = sortOrder.value === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortKey.value = key;
                        sortOrder.value = 'asc';
                    }
                };

                const loadedCount = computed(() => coins.value.length);

                const loadPercent = computed(() => {
                    if (!coins.value.length) return 0;
                    return 100;
                });

                const stats = computed(() => {
                    let bullish = 0, bearish = 0, neutral = 0;
                    coins.value.forEach(c => {
                        const arr = [c.trends?.m15, c.trends?.h1, c.trends?.h4, c.trends?.d1];
                        const buys = arr.filter(x => x === 'UP').length;
                        const sells = arr.filter(x => x === 'DOWN').length;
                        if (buys > sells) bullish++;
                        else if (sells > buys) bearish++;
                        else neutral++;
                    });
                    return { bullish, bearish, neutral };
                });

                function scoreInfo(coin) {
                    const arr = [coin.trends?.m15, coin.trends?.h1, coin.trends?.h4, coin.trends?.d1];
                    const buys = arr.filter(x => x === 'UP').length;
                    const sells = arr.filter(x => x === 'DOWN').length;
                    const diff = buys - sells;
                    if (diff >= 2) return { label: 'å¼ºçœ‹æ¶¨', klass: 'score-strong-buy' };
                    if (diff === 1) return { label: 'çœ‹æ¶¨', klass: 'score-buy' };
                    if (diff === 0) return { label: 'ä¸­æ€§', klass: 'score-neutral' };
                    if (diff === -1) return { label: 'çœ‹è·Œ', klass: 'score-sell' };
                    return { label: 'å¼ºçœ‹è·Œ', klass: 'score-strong-sell' };
                }

                function generateMiniChart(coin) {
                    if (!coin || !coin.sparkline || coin.sparkline.length < 2) return '<svg class="mini-chart"></svg>';
                    
                    const values = coin.sparkline;
                    const min = Math.min(...values);
                    const max = Math.max(...values);
                    const range = max - min || 1;
                    
                    const width = 80;
                    const height = 32;
                    const padding = 2;
                    
                    // åæ ‡è®¡ç®—
                    const points = values.map((v, i) => {
                        const x = (i / (values.length - 1)) * width;
                        const y = height - padding - ((v - min) / range) * (height - 2 * padding);
                        return `${x},${y}`;
                    }).join(' ');

                    const isUp = values[values.length - 1] >= values[0];
                    const strokeColor = isUp ? '#3fb950' : '#f85149';
                    const fillColor = isUp ? '#3fb950' : '#f85149';
                    
                    // æ¸å˜å¡«å……è·¯å¾„ (é—­åˆåˆ°åº•éƒ¨)
                    // æ³¨æ„ï¼šSVG path å‘½ä»¤ä¹‹é—´éœ€è¦ç©ºæ ¼åˆ†éš”
                    const firstPoint = points.split(' ')[0];
                    const lastPoint = points.split(' ')[points.split(' ').length - 1];
                    // æ„é€ é—­åˆè·¯å¾„: M(èµ·ç‚¹) -> polylineç‚¹ -> L(å³ä¸‹) -> L(å·¦ä¸‹) -> Z
                    const polyPoints = points.replaceAll(',', ' '); // polyline points format: x1 y1 x2 y2 ...
                    
                    // ä½¿ç”¨ path å‘½ä»¤æ‰‹åŠ¨æ„å»ºï¼Œæ›´ç¨³å¥
                    // M x0,y0 L x1,y1 ...
                    const linePathCmd = 'M ' + points.split(' ').join(' L ');
                    
                    const fillPathCmd = linePathCmd + ` L ${width},${height} L 0,${height} Z`;

                    return `
                        <svg class="mini-chart" viewBox="0 0 ${width} ${height}" preserveAspectRatio="none" style="overflow: visible;">
                            <defs>
                                <linearGradient id="grad-${coin.symbol}" x1="0%" y1="0%" x2="0%" y2="100%">
                                    <stop offset="0%" stop-color="${fillColor}" stop-opacity="0.2"/>
                                    <stop offset="100%" stop-color="${fillColor}" stop-opacity="0.0"/>
                                </linearGradient>
                            </defs>
                            <path d="${fillPathCmd}" fill="url(#grad-${coin.symbol})" stroke="none" />
                            <path d="${linePathCmd}" fill="none" stroke="${strokeColor}" stroke-width="1.5" stroke-linejoin="round" stroke-linecap="round"/>
                        </svg>
                    `;
                }

                function coinIconUrl(symbol) {
                    if (!symbol) return '';
                    return `https://assets.coincap.io/assets/icons/${symbol.toLowerCase()}@2x.png`;
                }

                function coinColor(symbol) {
                    const colors = { BTC:'#F7931A', ETH:'#627EEA', BNB:'#F3BA2F', XRP:'#23292F', SOL:'#00FFA3' };
                    if (colors[symbol]) return colors[symbol];
                    let hash = 0;
                    for (let i=0;i<symbol.length;i++) hash = symbol.charCodeAt(i) + ((hash<<5) - hash);
                    const hue = Math.abs(hash) % 360;
                    return `hsl(${hue}, 60%, 50%)`;
                }

                // --- é…ç½® ---
                // 1. æœ¬åœ°å¼€å‘: ä½¿ç”¨ 'http://localhost:8001/api/dashboard'
                // 2. çº¿ä¸Šéƒ¨ç½²: è¯·å°†ä¸‹é¢çš„åœ°å€ä¿®æ”¹ä¸ºä½  Render åç«¯çš„å®é™…åœ°å€
                //    ä¾‹å¦‚: 'https://supertrend-backend.onrender.com/api/dashboard'
                const API_URL = 'http://localhost:8001/api/dashboard'; 

                const fetchData = async () => {
                    loading.value = true;
                    error.value = null;
                    try {
                        const res = await fetch(API_URL);
                        if (!res.ok) throw new Error('HTTP ' + res.status);
                        const json = await res.json();

                        if (!json.coins || json.coins.length === 0) {
                            error.value = "åç«¯æ­£åœ¨æŠ“å–åˆå§‹æ•°æ®ï¼Œè¯·ç¨ç­‰ç‰‡åˆ»...";
                            setTimeout(fetchData, 3000);
                            return;
                        }

                        const rawCoins = json.coins || [];
                        coins.value = rawCoins.map((c, idx) => {
                            const backendTrends = c.trends || {};
                            const mappedTrends = {
                                m15: backendTrends['15m'] || 'N/A',
                                h1: backendTrends['1H'] || 'N/A',
                                h4: backendTrends['4H'] || 'N/A',
                                d1: backendTrends['1D'] || 'N/A'
                            };
                            return {
                                rank: idx + 1,
                                name: c.symbol,
                                symbol: c.symbol,
                                image: coinIconUrl(c.symbol),
                                price: c.price,
                                change24h: c.change24h,
                                volume24h: c.volume24h,
                                trends: mappedTrends,
                                sparkline: c.sparkline || []
                            };
                        });

                        lastUpdated.value = json.lastUpdated || null;
                    } catch (e) {
                        console.error('Fetch error', e);
                        error.value = "æ— æ³•è¿æ¥åç«¯ï¼Œè¯·ç¡®ä¿ start_server.bat å·²è¿è¡Œ";
                    } finally {
                        loading.value = false;
                    }
                };

                onMounted(() => {
                    fetchData();
                    setInterval(fetchData, 180000); // Refresh every 180s (3 min)
                });

                return {
                    coins,
                    loading,
                    lastUpdatedFormatted,
                    searchQuery,
                    filteredCoins,
                    fetchData,
                    formatPrice,
                    sortKey,
                    sortOrder,
                    sortBy,
                    filterStatus,
                    setFilter,
                    loadedCount,
                    loadPercent,
                    stats,
                    coinColor,
                    generateMiniChart,
                    scoreInfo
                };
            }
        }).mount('#app');
    </script>
</body>
</html>
